import { Request, Response } from "express";
import { hash, compare } from "bcrypt";
import { randomUUID } from "crypto";

import Code from "../models/code.js";
import User from "../models/user.js";
import Token from "../models/token.js";
import { transporter, getEmailOptions } from "../config/nodemailer.js";
import { createTemporaryToken } from "../config/jsonwebtoken.js";

// Length 6
const _getRandomCode = (): number => {
  return Math.floor(Math.random() * (999999 - 100000 + 1)) + 100000;
};

const register = async (request: Request, response: Response) => {
  const { email, password } = request.body;

  // Codify password for security
  // Nobody know your real password
  const codifiedPassword = await hash(password, 10);
  const storedUser = await User.create({
    name: "John Doe",
    email: email,
    codifiedPassword: codifiedPassword,
    chatId: randomUUID(),
  });
  if (storedUser === null) {
    response.status(500).json({ message: "CAN'T CREATE USER" });
    return;
  }

  response.status(200).json({ message: "USER CREATED SUCCESSFUL." });
};

// This code is being confuse
// I should refactor it in steps
const logIn = async (request: Request, response: Response) => {
  const { email, password } = request.body;
  const requesterIp = request.ip;

  // Find and checks if user requested exists
  const user = await User.findOne({ email: email });
  if (user === null) {
    response.status(400).json({ message: "TRY AGAIN." });
    return;
  }

  // Compare and checks if codified password
  // was generated by requester password
  const isPasswordCorrect: boolean = await compare(
    password,
    user.codifiedPassword
  );
  if (!isPasswordCorrect) {
    response.status(400).json({ message: "TRY AGAIN." });
    return;
  }

  // If user has an active token
  // then delete it and create a new one
  const alreadyExistsToken = await Token.findOne({
    "onwer.id": user._id,
  });
  if (alreadyExistsToken !== null) {
    await alreadyExistsToken.deleteOne();
  }

  // Create and store a token with user
  // inforamtions to compare it later
  const storedToken = await Token.create({
    onwer: {
      id: user._id,
      ip: requesterIp,
    },
  });
  if (storedToken === null) {
    response.status(400).json({ message: "CAN'T CREATE ACCESS TOKEN" });
    return;
  }

  // Creates a codified token to prevent
  // brute force attacks to token id
  const temporaryToken = createTemporaryToken({
    tokenId: storedToken._id,
  });

  response
    .status(200)
    .json({ message: "SUCCESSFUL LOGIN.", privateToken: temporaryToken });
};

const generateCodeAndSendToEmail = async (
  request: Request,
  response: Response
) => {
  const { email } = request.body;
  const requesterIp = request.ip;

  const alreadyExistsCode = await Code.findOne({
    "requester.email": email,
  });
  if (alreadyExistsCode !== null) {
    await alreadyExistsCode.deleteOne();
  }

  // Create and store code with user informations
  // to compare it later
  const randomCode = _getRandomCode();
  const storedCode = await Code.create({
    code: randomCode,
    requester: {
      ip: requesterIp,
      email: email,
    },
  });
  if (storedCode === null) {
    response.status(500).json({ message: "CAN'T CREATE CODE." });
    return;
  }

  // Send code to user's email requested
  const emailOptions = getEmailOptions(email, randomCode);
  transporter.sendMail(emailOptions, (error) => {
    if (error !== null) {
      response.status(500).json({ message: "CAN'T SEND CODE." });
      return;
    }
  });

  response
    .status(200)
    .json({ message: "CODE CREATED.", codeId: storedCode._id });
};

export default {
  logIn,
  register,
  generateCodeAndSendToEmail,
};
